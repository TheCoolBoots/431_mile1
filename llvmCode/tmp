fun f (int x, int y) int
{
    int sum;
    if (x >= y)
    {
        return 0;
    }
    sum = 0;
    while (x < y)
    {
        if (x/2 * 2 == x)
        {
            sum = sum + 1;
        }
        x = x + 1
    }
    return sum;
}

block 1 = line 1 - 4
r1 = %x >= %y       x : %x, y : %y
br r1 l1, l2

block l1 = line 6
br LE               retVal = 0

block l2 = line 8-9
r3 = %x < %y        x : %x, y : %y, sum : 0
br r3 l3, l4

block l3 = line 11
r4 = phi(%x, __)    # don't know what x will be yet, leave it unsealed
r8 = phi(0, __)     # r8 assigned empty phi node for value of sum
r5 = r4 / 2         x : r4, sum : r8
r6 = r5 * 2     
r7 = r6 == r4
r12 = phi(%y, __)
br r7 l5, l6

final fill in pass: r11, r15, r13

block l5 = line 13
r9 = r8 + 1         sum : r9, y: r12
br l7

block l6 = empty else node
br l7               y: r12

block l7 = line 15
r10 = phi(r4, r4)   x : r10
r11 = r10 + 1       x : r11
r15 = phi(r9, r8)   sum : r15
r13 = phi(r12, r12)
r14 = r11 < r13

block l4 = line 17
r16 = phi(r15, 0)   # traverses back and gets all the possible values of sum
                    sum : r16

block LE = phantom end block
r17 = phi(r16, 0)   


# copy down while check which is block l2
* goes and searches for value of y
needs to add a new phi node b/c l3 unsealed


AFTER ALL THAT DO CLEANUP
r10 = r4
r13 = r12
OR
replace all instances of r10/r13 with r4/r12

